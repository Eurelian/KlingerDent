webpackHotUpdate("static\\development\\pages\\praxis.js",{

/***/ "./components/praxisText.js":
/*!**********************************!*\
  !*** ./components/praxisText.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! framer-motion */ "./node_modules/framer-motion/dist/framer-motion.es.js");
/* harmony import */ var react_intersection_observer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-intersection-observer */ "./node_modules/react-intersection-observer/react-intersection-observer.esm.js");



var _this = undefined,
    _jsxFileName = "E:\\WEB DEV PROJECTS 2020\\Klinger Clinic\\components\\praxisText.js",
    _s = $RefreshSig$();


var __jsx = react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement;



var PraxisText = function PraxisText() {
  _s();

  var arr = Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Array(10).keys());

  var _useInView = Object(react_intersection_observer__WEBPACK_IMPORTED_MODULE_4__["useInView"])({
    /* Optional options */
    threshold: 0
  }),
      _useInView2 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_useInView, 3),
      ref = _useInView2[0],
      inView = _useInView2[1],
      entry = _useInView2[2];

  return __jsx("div", {
    className: "pt-5 container",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 3
    }
  }, __jsx("div", {
    className: "row m-0 mb-3",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 4
    }
  }, __jsx("h1", {
    className: "section-title",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 5
    }
  }, "Klinger Praxis")), __jsx("div", {
    className: "row align-items-center mb-5",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 4
    }
  }, __jsx("div", {
    className: "col-md-7 mb-4",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 5
    }
  }, " ", __jsx("p", {
    className: "section-text",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 6
    }
  }, "Die Praxis der Klinger Zahn\xE4rzte liegt direkt im Herzen von Z\xFCrich, direkt am Bellevue und dem sch\xF6nen Z\xFCrich-See. Dort bieten wir Ihnen allgemeine sowie \xE4sthetische Zahnmedizin mittels modernster, schonendster und schmerzfreier Verfahrensweisen \u2013 auf h\xF6chstem Niveau. Modernste Ausstattung in unserer Zahnarztpraxis in Z\xFCrich ist f\xFCr uns eine unumg\xE4ngliche Voraussetzung um eine erfolgreiche Behandlung zu erm\xF6glichen. Daher investieren wir laufend in neue zahnmedizinische Instrumente. Zu unseren neuesten Anschaffungen z\xE4hlt beispielsweise der 3D-Volumentomograph von Kodak und das Cerec-3D Ger\xE4t von Sirona, welches wir f\xFCr die Zahnersatz-Behandlung verwenden.")), __jsx("div", {
    className: "col-md-5 mb-4",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "img-background",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 6
    }
  }), __jsx("img", {
    className: "img-fluid rounded hero-img ",
    alt: "praxis klinger",
    src: "/slide_1.jpg",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 6
    }
  }))), __jsx("div", {
    className: "row align-items-center mb-5",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 4
    }
  }, __jsx("div", {
    className: "col-md-5 mb-4",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "img-background",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 45,
      columnNumber: 6
    }
  }), __jsx("img", {
    className: "img-fluid rounded hero-img ",
    src: "/slide_1.jpg",
    alt: "praxis klinger",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 46,
      columnNumber: 6
    }
  })), __jsx("div", {
    className: "col-md-7 pl-5",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 52,
      columnNumber: 5
    }
  }, __jsx("p", {
    className: "section-text",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 53,
      columnNumber: 6
    }
  }, " ", "Ihre Zahnbehandlung in der Bellevue Zahnklinik erfolgt also ausschliesslich mittels modernster Ger\xE4te und neuester Ausstattung. In der Praxis der Bellevue Zahn\xE4rzte werden Sie ausschliesslich von gut ausgebildeten Zahn\xE4rzten behandelt, die \xFCber verschiedenste Fachausbildungen und Spezialisierungen verf\xFCgen \u2013 eine weitere Garantie f\xFCr die bestm\xF6gliche Behandlung Ihrer Z\xE4hne. Unser \xC4rzteteam wird erg\xE4nzt durch diplomierte Dentalhygienikerinnen, die sich mit viel Feingef\xFChl und den modernsten Produkten um Ihre Zahnhygiene bem\xFChen."))), __jsx("div", {
    className: "row mb-4 pt-4 justify-content-center",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 67,
      columnNumber: 4
    }
  }, __jsx("h1", {
    className: "section-title",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 5
    }
  }, "Das Team")), __jsx("div", {
    className: "row d-flex justify-content-center m-0 mb-5",
    style: {
      width: "100%"
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 4
    }
  }, arr.map(function (item, i) {
    return __jsx("div", {
      key: i,
      className: "col-auto m-0",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 75,
        columnNumber: 6
      }
    }, __jsx("div", {
      className: "text-center",
      style: {
        width: "18rem"
      },
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 76,
        columnNumber: 7
      }
    }, __jsx("div", {
      className: "avatar-img",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 77,
        columnNumber: 8
      }
    }, __jsx("img", {
      className: "img-fluid rounded-circle ",
      src: "https://images.unsplash.com/photo-1580489944761-15a19d654956?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=698&q=80",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 78,
        columnNumber: 9
      }
    })), __jsx("div", {
      className: "card-body pt-5",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 83,
        columnNumber: 8
      }
    }, __jsx("h5", {
      className: "card-title",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 84,
        columnNumber: 9
      }
    }, "Harry Klinger"), __jsx("p", {
      className: "card-text",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 85,
        columnNumber: 9
      }
    }, "With supporting text below as a natural lead-in to additional content."))));
  })));
};

_s(PraxisText, "xcNnOkK/eOBEx/AJ1BTvf70kBfM=", false, function () {
  return [react_intersection_observer__WEBPACK_IMPORTED_MODULE_4__["useInView"]];
});

_c = PraxisText;
/* harmony default export */ __webpack_exports__["default"] = (PraxisText);

var _c;

$RefreshReg$(_c, "PraxisText");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/react-intersection-observer/react-intersection-observer.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-intersection-observer/react-intersection-observer.esm.js ***!
  \*************************************************************************************/
/*! exports provided: default, InView, useInView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InView", function() { return InView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useInView", function() { return useInView; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");



function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var INSTANCE_MAP = new Map();
var OBSERVER_MAP = new Map();
var ROOT_IDS = new Map();
var consecutiveRootId = 0;
/**
 * Generate a unique ID for the root element
 * @param root
 */

function getRootId(root) {
  if (!root) return '';
  if (ROOT_IDS.has(root)) return ROOT_IDS.get(root);
  consecutiveRootId += 1;
  ROOT_IDS.set(root, consecutiveRootId.toString());
  return ROOT_IDS.get(root) + '_';
}
/**
 * Monitor element, and trigger callback when element becomes inView
 * @param element {HTMLElement}
 * @param callback {Function} Called with inView
 * @param options {Object} InterSection observer options
 * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be inView before triggering
 * @param options.root {HTMLElement}
 * @param options.rootMargin {String} The CSS margin to apply to the root element.
 */


function observe(element, callback, options) {
  if (options === void 0) {
    options = {};
  }

  // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.
  // Modify the options object, since it's used in the onChange handler.
  if (!options.threshold) options.threshold = 0;
  var _options = options,
      root = _options.root,
      rootMargin = _options.rootMargin,
      threshold = _options.threshold; // Validate that the element is not being used in another <Observer />

  !!INSTANCE_MAP.has(element) ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_1__["default"])(false, "react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\nMake sure the `ref` is only used by a single <Observer /> instance.\n\n%s") : undefined : void 0;
  /* istanbul ignore if */

  if (!element) return; // Create a unique ID for this observer instance, based on the root, root margin and threshold.
  // An observer with the same options can be reused, so lets use this fact

  var observerId = getRootId(root) + (rootMargin ? threshold.toString() + "_" + rootMargin : threshold.toString());
  var observerInstance = OBSERVER_MAP.get(observerId);

  if (!observerInstance) {
    observerInstance = new IntersectionObserver(onChange, options);
    /* istanbul ignore else  */

    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);
  }

  var instance = {
    callback: callback,
    element: element,
    inView: false,
    observerId: observerId,
    observer: observerInstance,
    // Make sure we have the thresholds value. It's undefined on a browser like Chrome 51.
    thresholds: observerInstance.thresholds || (Array.isArray(threshold) ? threshold : [threshold])
  };
  INSTANCE_MAP.set(element, instance);
  observerInstance.observe(element);
  return instance;
}
/**
 * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,
 * make sure to call this method.
 * @param element {Element}
 */

function unobserve(element) {
  if (!element) return;
  var instance = INSTANCE_MAP.get(element);

  if (instance) {
    var observerId = instance.observerId,
        observer = instance.observer;
    var root = observer.root;
    observer.unobserve(element); // Check if we are still observing any elements with the same threshold.

    var itemsLeft = false; // Check if we still have observers configured with the same root.

    var rootObserved = false;
    /* istanbul ignore else  */

    if (observerId) {
      INSTANCE_MAP.forEach(function (item, key) {
        if (key !== element) {
          if (item.observerId === observerId) {
            itemsLeft = true;
            rootObserved = true;
          }

          if (item.observer.root === root) {
            rootObserved = true;
          }
        }
      });
    }

    if (!rootObserved && root) ROOT_IDS["delete"](root);

    if (observer && !itemsLeft) {
      // No more elements to observe for threshold, disconnect observer
      observer.disconnect();
    } // Remove reference to element


    INSTANCE_MAP["delete"](element);
  }
}

function onChange(changes) {
  changes.forEach(function (intersection) {
    var isIntersecting = intersection.isIntersecting,
        intersectionRatio = intersection.intersectionRatio,
        target = intersection.target;
    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling.

    /* istanbul ignore else */

    if (instance && intersectionRatio >= 0) {
      // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.
      var inView = instance.thresholds.some(function (threshold) {
        return instance.inView ? intersectionRatio > threshold : intersectionRatio >= threshold;
      });

      if (isIntersecting !== undefined) {
        // If isIntersecting is defined, ensure that the element is actually intersecting.
        // Otherwise it reports a threshold of 0
        inView = inView && isIntersecting;
      }

      instance.inView = inView;
      instance.callback(inView, intersection);
    }
  });
}

function isPlainChildren(props) {
  return typeof props.children !== 'function';
}
/**
 * Monitors scroll, and triggers the children function with updated props
 *
 <InView>
 {({inView, ref}) => (
   <h1 ref={ref}>{`${inView}`}</h1>
 )}
 </InView>
 */


var InView = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(InView, _React$Component);

  function InView() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      inView: false,
      entry: undefined
    });

    _defineProperty(_assertThisInitialized(_this), "node", null);

    _defineProperty(_assertThisInitialized(_this), "handleNode", function (node) {
      if (_this.node) {
        unobserve(_this.node);

        if (!node && !_this.props.triggerOnce) {
          _this.setState({
            inView: false,
            entry: undefined
          });
        }
      }

      _this.node = node ? node : null;

      _this.observeNode();
    });

    _defineProperty(_assertThisInitialized(_this), "handleChange", function (inView, entry) {
      // Only trigger a state update if inView has changed.
      // This prevents an unnecessary extra state update during mount, when the element stats outside the viewport
      if (inView !== _this.state.inView || inView) {
        _this.setState({
          inView: inView,
          entry: entry
        });
      }

      if (_this.props.onChange) {
        // If the user is actively listening for onChange, always trigger it
        _this.props.onChange(inView, entry);
      }
    });

    return _this;
  }

  var _proto = InView.prototype;

  _proto.componentDidMount = function componentDidMount() {
    !this.node ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_1__["default"])(false, "react-intersection-observer: No DOM node found. Make sure you forward \"ref\" to the root DOM element you want to observe.") : undefined : void 0;
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // If a IntersectionObserver option changed, reinit the observer
    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold) {
      unobserve(this.node);
      this.observeNode();
    }

    if (prevState.inView !== this.state.inView) {
      if (this.state.inView && this.props.triggerOnce) {
        unobserve(this.node);
        this.node = null;
      }
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.node) {
      unobserve(this.node);
      this.node = null;
    }
  };

  _proto.observeNode = function observeNode() {
    if (!this.node) return;
    var _this$props = this.props,
        threshold = _this$props.threshold,
        root = _this$props.root,
        rootMargin = _this$props.rootMargin;
    observe(this.node, this.handleChange, {
      threshold: threshold,
      root: root,
      rootMargin: rootMargin
    });
  };

  _proto.render = function render() {
    var _this$state = this.state,
        inView = _this$state.inView,
        entry = _this$state.entry;

    if (!isPlainChildren(this.props)) {
      return this.props.children({
        inView: inView,
        entry: entry,
        ref: this.handleNode
      });
    }

    var _this$props2 = this.props,
        children = _this$props2.children,
        as = _this$props2.as,
        tag = _this$props2.tag,
        triggerOnce = _this$props2.triggerOnce,
        threshold = _this$props2.threshold,
        root = _this$props2.root,
        rootMargin = _this$props2.rootMargin,
        onChange = _this$props2.onChange,
        props = _objectWithoutPropertiesLoose(_this$props2, ["children", "as", "tag", "triggerOnce", "threshold", "root", "rootMargin", "onChange"]);

    return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(as || tag || 'div', _extends({
      ref: this.handleNode
    }, props), children);
  };

  return InView;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

_defineProperty(InView, "displayName", 'InView');

_defineProperty(InView, "defaultProps", {
  threshold: 0,
  triggerOnce: false
});

/* eslint-disable react-hooks/exhaustive-deps */
var initialState = {
  inView: false,
  entry: undefined
};
function useInView(options) {
  if (options === void 0) {
    options = {};
  }

  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();

  var _React$useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(initialState),
      state = _React$useState[0],
      setState = _React$useState[1];

  var setRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useCallback"])(function (node) {
    if (ref.current) {
      unobserve(ref.current);
    }

    if (node) {
      observe(node, function (inView, intersection) {
        setState({
          inView: inView,
          entry: intersection
        });

        if (inView && options.triggerOnce) {
          // If it should only trigger once, unobserve the element after it's inView
          unobserve(node);
        }
      }, options);
    } // Store a reference to the node, so we can unobserve it later


    ref.current = node;
  }, [options.threshold, options.root, options.rootMargin, options.triggerOnce]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    if (!ref.current && state !== initialState && !options.triggerOnce) {
      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce`)
      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView
      setState(initialState);
    }
  });
  return [setRef, state.inView, state.entry];
}

/* harmony default export */ __webpack_exports__["default"] = (InView);



/***/ }),

/***/ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isProduction = "development" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    throw new Error(prefix + ": " + (message || ''));
}

/* harmony default export */ __webpack_exports__["default"] = (invariant);


/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3ByYXhpc1RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlci9yZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW55LWludmFyaWFudC9kaXN0L3RpbnktaW52YXJpYW50LmVzbS5qcyJdLCJuYW1lcyI6WyJQcmF4aXNUZXh0IiwiYXJyIiwiQXJyYXkiLCJrZXlzIiwidXNlSW5WaWV3IiwidGhyZXNob2xkIiwicmVmIiwiaW5WaWV3IiwiZW50cnkiLCJ3aWR0aCIsIm1hcCIsIml0ZW0iLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUEsSUFBTUEsVUFBVSxHQUFHLFNBQWJBLFVBQWEsR0FBTTtBQUFBOztBQUN4QixNQUFNQyxHQUFHLEdBQUcsNkZBQUlDLEtBQUssQ0FBQyxFQUFELENBQUwsQ0FBVUMsSUFBVixFQUFQLENBQVQ7O0FBRHdCLG1CQUVLQyw2RUFBUyxDQUFDO0FBQ3RDO0FBQ0FDLGFBQVMsRUFBRTtBQUYyQixHQUFELENBRmQ7QUFBQTtBQUFBLE1BRWpCQyxHQUZpQjtBQUFBLE1BRVpDLE1BRlk7QUFBQSxNQUVKQyxLQUZJOztBQU14QixTQUNDO0FBQUssYUFBUyxFQUFDLGdCQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDQztBQUFLLGFBQVMsRUFBQyxjQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDQztBQUFJLGFBQVMsRUFBQyxlQUFkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBREQsQ0FERCxFQUlDO0FBQUssYUFBUyxFQUFDLDZCQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDQztBQUFLLGFBQVMsRUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDJEQUFhO0FBQ3hCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLCtDQUFTOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksb0RBQU07O0FBRWxCLHdCQUF3QixzREFBUTtBQUNoQztBQUNBOztBQUVBLGVBQWUseURBQVc7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0EsR0FBRztBQUNILEVBQUUsdURBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRWUscUVBQU0sRUFBQztBQUNPOzs7Ozs7Ozs7Ozs7O0FDdlo3QjtBQUFBLG1CQUFtQixhQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSx3RUFBUyxFQUFDIiwiZmlsZSI6InN0YXRpYy93ZWJwYWNrL3N0YXRpY1xcZGV2ZWxvcG1lbnRcXHBhZ2VzXFxwcmF4aXMuanMuM2U5Y2Y5MTMwYWRiN2ZiYjljYWYuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XHJcbmltcG9ydCB7IHVzZUluVmlldyB9IGZyb20gXCJyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXJcIjtcclxuXHJcbmNvbnN0IFByYXhpc1RleHQgPSAoKSA9PiB7XHJcblx0Y29uc3QgYXJyID0gWy4uLkFycmF5KDEwKS5rZXlzKCldO1xyXG5cdGNvbnN0IFtyZWYsIGluVmlldywgZW50cnldID0gdXNlSW5WaWV3KHtcclxuXHRcdC8qIE9wdGlvbmFsIG9wdGlvbnMgKi9cclxuXHRcdHRocmVzaG9sZDogMCxcclxuXHR9KTtcclxuXHRyZXR1cm4gKFxyXG5cdFx0PGRpdiBjbGFzc05hbWU9J3B0LTUgY29udGFpbmVyJz5cclxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J3JvdyBtLTAgbWItMyc+XHJcblx0XHRcdFx0PGgxIGNsYXNzTmFtZT0nc2VjdGlvbi10aXRsZSc+S2xpbmdlciBQcmF4aXM8L2gxPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PGRpdiBjbGFzc05hbWU9J3JvdyBhbGlnbi1pdGVtcy1jZW50ZXIgbWItNSc+XHJcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbC1tZC03IG1iLTQnPlxyXG5cdFx0XHRcdFx0e1wiIFwifVxyXG5cdFx0XHRcdFx0PHAgY2xhc3NOYW1lPSdzZWN0aW9uLXRleHQnPlxyXG5cdFx0XHRcdFx0XHREaWUgUHJheGlzIGRlciBLbGluZ2VyIFphaG7DpHJ6dGUgbGllZ3QgZGlyZWt0IGltIEhlcnplbiB2b24gWsO8cmljaCxcclxuXHRcdFx0XHRcdFx0ZGlyZWt0IGFtIEJlbGxldnVlIHVuZCBkZW0gc2Now7ZuZW4gWsO8cmljaC1TZWUuIERvcnQgYmlldGVuIHdpciBJaG5lblxyXG5cdFx0XHRcdFx0XHRhbGxnZW1laW5lIHNvd2llIMOkc3RoZXRpc2NoZSBaYWhubWVkaXppbiBtaXR0ZWxzIG1vZGVybnN0ZXIsXHJcblx0XHRcdFx0XHRcdHNjaG9uZW5kc3RlciB1bmQgc2NobWVyemZyZWllciBWZXJmYWhyZW5zd2Vpc2VuIOKAkyBhdWYgaMO2Y2hzdGVtXHJcblx0XHRcdFx0XHRcdE5pdmVhdS4gTW9kZXJuc3RlIEF1c3N0YXR0dW5nIGluIHVuc2VyZXIgWmFobmFyenRwcmF4aXMgaW4gWsO8cmljaFxyXG5cdFx0XHRcdFx0XHRpc3QgZsO8ciB1bnMgZWluZSB1bnVtZ8OkbmdsaWNoZSBWb3JhdXNzZXR6dW5nIHVtIGVpbmUgZXJmb2xncmVpY2hlXHJcblx0XHRcdFx0XHRcdEJlaGFuZGx1bmcgenUgZXJtw7ZnbGljaGVuLiBEYWhlciBpbnZlc3RpZXJlbiB3aXIgbGF1ZmVuZCBpbiBuZXVlXHJcblx0XHRcdFx0XHRcdHphaG5tZWRpemluaXNjaGUgSW5zdHJ1bWVudGUuIFp1IHVuc2VyZW4gbmV1ZXN0ZW4gQW5zY2hhZmZ1bmdlblxyXG5cdFx0XHRcdFx0XHR6w6RobHQgYmVpc3BpZWxzd2Vpc2UgZGVyIDNELVZvbHVtZW50b21vZ3JhcGggdm9uIEtvZGFrIHVuZCBkYXNcclxuXHRcdFx0XHRcdFx0Q2VyZWMtM0QgR2Vyw6R0IHZvbiBTaXJvbmEsIHdlbGNoZXMgd2lyIGbDvHIgZGllIFphaG5lcnNhdHotQmVoYW5kbHVuZ1xyXG5cdFx0XHRcdFx0XHR2ZXJ3ZW5kZW4uXHJcblx0XHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0PC9kaXY+XHJcblxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdjb2wtbWQtNSBtYi00Jz5cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPSdpbWctYmFja2dyb3VuZCc+PC9kaXY+XHJcblxyXG5cdFx0XHRcdFx0PGltZ1xyXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9J2ltZy1mbHVpZCByb3VuZGVkIGhlcm8taW1nICdcclxuXHRcdFx0XHRcdFx0YWx0PSdwcmF4aXMga2xpbmdlcidcclxuXHRcdFx0XHRcdFx0c3JjPScvc2xpZGVfMS5qcGcnXHJcblx0XHRcdFx0XHQ+PC9pbWc+XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT0ncm93IGFsaWduLWl0ZW1zLWNlbnRlciBtYi01Jz5cclxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nY29sLW1kLTUgbWItNCc+XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0naW1nLWJhY2tncm91bmQnPjwvZGl2PlxyXG5cdFx0XHRcdFx0PGltZ1xyXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9J2ltZy1mbHVpZCByb3VuZGVkIGhlcm8taW1nICdcclxuXHRcdFx0XHRcdFx0c3JjPScvc2xpZGVfMS5qcGcnXHJcblx0XHRcdFx0XHRcdGFsdD0ncHJheGlzIGtsaW5nZXInXHJcblx0XHRcdFx0XHQ+PC9pbWc+XHJcblx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2NvbC1tZC03IHBsLTUnPlxyXG5cdFx0XHRcdFx0PHAgY2xhc3NOYW1lPSdzZWN0aW9uLXRleHQnPlxyXG5cdFx0XHRcdFx0XHR7XCIgXCJ9XHJcblx0XHRcdFx0XHRcdElocmUgWmFobmJlaGFuZGx1bmcgaW4gZGVyIEJlbGxldnVlIFphaG5rbGluaWsgZXJmb2xndCBhbHNvXHJcblx0XHRcdFx0XHRcdGF1c3NjaGxpZXNzbGljaCBtaXR0ZWxzIG1vZGVybnN0ZXIgR2Vyw6R0ZSB1bmQgbmV1ZXN0ZXIgQXVzc3RhdHR1bmcuXHJcblx0XHRcdFx0XHRcdEluIGRlciBQcmF4aXMgZGVyIEJlbGxldnVlIFphaG7DpHJ6dGUgd2VyZGVuIFNpZSBhdXNzY2hsaWVzc2xpY2ggdm9uXHJcblx0XHRcdFx0XHRcdGd1dCBhdXNnZWJpbGRldGVuIFphaG7DpHJ6dGVuIGJlaGFuZGVsdCwgZGllIMO8YmVyIHZlcnNjaGllZGVuc3RlXHJcblx0XHRcdFx0XHRcdEZhY2hhdXNiaWxkdW5nZW4gdW5kIFNwZXppYWxpc2llcnVuZ2VuIHZlcmbDvGdlbiDigJMgZWluZSB3ZWl0ZXJlXHJcblx0XHRcdFx0XHRcdEdhcmFudGllIGbDvHIgZGllIGJlc3Rtw7ZnbGljaGUgQmVoYW5kbHVuZyBJaHJlciBaw6RobmUuIFVuc2VyXHJcblx0XHRcdFx0XHRcdMOEcnp0ZXRlYW0gd2lyZCBlcmfDpG56dCBkdXJjaCBkaXBsb21pZXJ0ZSBEZW50YWxoeWdpZW5pa2VyaW5uZW4sIGRpZVxyXG5cdFx0XHRcdFx0XHRzaWNoIG1pdCB2aWVsIEZlaW5nZWbDvGhsIHVuZCBkZW4gbW9kZXJuc3RlbiBQcm9kdWt0ZW4gdW0gSWhyZVxyXG5cdFx0XHRcdFx0XHRaYWhuaHlnaWVuZSBiZW3DvGhlbi5cclxuXHRcdFx0XHRcdDwvcD5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxkaXYgY2xhc3NOYW1lPSdyb3cgbWItNCBwdC00IGp1c3RpZnktY29udGVudC1jZW50ZXInPlxyXG5cdFx0XHRcdDxoMSBjbGFzc05hbWU9J3NlY3Rpb24tdGl0bGUnPkRhcyBUZWFtPC9oMT5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxkaXZcclxuXHRcdFx0XHRjbGFzc05hbWU9J3JvdyBkLWZsZXgganVzdGlmeS1jb250ZW50LWNlbnRlciBtLTAgbWItNSdcclxuXHRcdFx0XHRzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIgfX1cclxuXHRcdFx0PlxyXG5cdFx0XHRcdHthcnIubWFwKChpdGVtLCBpKSA9PiAoXHJcblx0XHRcdFx0XHQ8ZGl2IGtleT17aX0gY2xhc3NOYW1lPSdjb2wtYXV0byBtLTAnPlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0ndGV4dC1jZW50ZXInIHN0eWxlPXt7IHdpZHRoOiBcIjE4cmVtXCIgfX0+XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9J2F2YXRhci1pbWcnPlxyXG5cdFx0XHRcdFx0XHRcdFx0PGltZ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9J2ltZy1mbHVpZCByb3VuZGVkLWNpcmNsZSAnXHJcblx0XHRcdFx0XHRcdFx0XHRcdHNyYz0naHR0cHM6Ly9pbWFnZXMudW5zcGxhc2guY29tL3Bob3RvLTE1ODA0ODk5NDQ3NjEtMTVhMTlkNjU0OTU2P2l4bGliPXJiLTEuMi4xJml4aWQ9ZXlKaGNIQmZhV1FpT2pFeU1EZDkmYXV0bz1mb3JtYXQmZml0PWNyb3Amdz02OTgmcT04MCdcclxuXHRcdFx0XHRcdFx0XHRcdD48L2ltZz5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT0nY2FyZC1ib2R5IHB0LTUnPlxyXG5cdFx0XHRcdFx0XHRcdFx0PGg1IGNsYXNzTmFtZT0nY2FyZC10aXRsZSc+SGFycnkgS2xpbmdlcjwvaDU+XHJcblx0XHRcdFx0XHRcdFx0XHQ8cCBjbGFzc05hbWU9J2NhcmQtdGV4dCc+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFdpdGggc3VwcG9ydGluZyB0ZXh0IGJlbG93IGFzIGEgbmF0dXJhbCBsZWFkLWluIHRvIGFkZGl0aW9uYWxcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGVudC5cclxuXHRcdFx0XHRcdFx0XHRcdDwvcD5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQpKX1cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L2Rpdj5cclxuXHQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJheGlzVGV4dDtcclxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG52YXIgSU5TVEFOQ0VfTUFQID0gbmV3IE1hcCgpO1xudmFyIE9CU0VSVkVSX01BUCA9IG5ldyBNYXAoKTtcbnZhciBST09UX0lEUyA9IG5ldyBNYXAoKTtcbnZhciBjb25zZWN1dGl2ZVJvb3RJZCA9IDA7XG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0gcm9vdFxuICovXG5cbmZ1bmN0aW9uIGdldFJvb3RJZChyb290KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuICcnO1xuICBpZiAoUk9PVF9JRFMuaGFzKHJvb3QpKSByZXR1cm4gUk9PVF9JRFMuZ2V0KHJvb3QpO1xuICBjb25zZWN1dGl2ZVJvb3RJZCArPSAxO1xuICBST09UX0lEUy5zZXQocm9vdCwgY29uc2VjdXRpdmVSb290SWQudG9TdHJpbmcoKSk7XG4gIHJldHVybiBST09UX0lEUy5nZXQocm9vdCkgKyAnXyc7XG59XG4vKipcbiAqIE1vbml0b3IgZWxlbWVudCwgYW5kIHRyaWdnZXIgY2FsbGJhY2sgd2hlbiBlbGVtZW50IGJlY29tZXMgaW5WaWV3XG4gKiBAcGFyYW0gZWxlbWVudCB7SFRNTEVsZW1lbnR9XG4gKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufSBDYWxsZWQgd2l0aCBpblZpZXdcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IEludGVyU2VjdGlvbiBvYnNlcnZlciBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucy50aHJlc2hvbGQge051bWJlcn0gTnVtYmVyIGJldHdlZW4gMCBhbmQgMSwgaW5kaWNhdGluZyBob3cgbXVjaCBvZiB0aGUgZWxlbWVudCBzaG91bGQgYmUgaW5WaWV3IGJlZm9yZSB0cmlnZ2VyaW5nXG4gKiBAcGFyYW0gb3B0aW9ucy5yb290IHtIVE1MRWxlbWVudH1cbiAqIEBwYXJhbSBvcHRpb25zLnJvb3RNYXJnaW4ge1N0cmluZ30gVGhlIENTUyBtYXJnaW4gdG8gYXBwbHkgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIEludGVyc2VjdGlvbk9ic2VydmVyIG5lZWRzIGEgdGhyZXNob2xkIHRvIHRyaWdnZXIsIHNvIHNldCBpdCB0byAwIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gIC8vIE1vZGlmeSB0aGUgb3B0aW9ucyBvYmplY3QsIHNpbmNlIGl0J3MgdXNlZCBpbiB0aGUgb25DaGFuZ2UgaGFuZGxlci5cbiAgaWYgKCFvcHRpb25zLnRocmVzaG9sZCkgb3B0aW9ucy50aHJlc2hvbGQgPSAwO1xuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcm9vdCA9IF9vcHRpb25zLnJvb3QsXG4gICAgICByb290TWFyZ2luID0gX29wdGlvbnMucm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZCA9IF9vcHRpb25zLnRocmVzaG9sZDsgLy8gVmFsaWRhdGUgdGhhdCB0aGUgZWxlbWVudCBpcyBub3QgYmVpbmcgdXNlZCBpbiBhbm90aGVyIDxPYnNlcnZlciAvPlxuXG4gICEhSU5TVEFOQ0VfTUFQLmhhcyhlbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXI6IFRyeWluZyB0byBvYnNlcnZlICVzLCBidXQgaXQncyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkIGJ5IGFub3RoZXIgaW5zdGFuY2UuXFxuTWFrZSBzdXJlIHRoZSBgcmVmYCBpcyBvbmx5IHVzZWQgYnkgYSBzaW5nbGUgPE9ic2VydmVyIC8+IGluc3RhbmNlLlxcblxcbiVzXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgaWYgKCFlbGVtZW50KSByZXR1cm47IC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBvYnNlcnZlciBpbnN0YW5jZSwgYmFzZWQgb24gdGhlIHJvb3QsIHJvb3QgbWFyZ2luIGFuZCB0aHJlc2hvbGQuXG4gIC8vIEFuIG9ic2VydmVyIHdpdGggdGhlIHNhbWUgb3B0aW9ucyBjYW4gYmUgcmV1c2VkLCBzbyBsZXRzIHVzZSB0aGlzIGZhY3RcblxuICB2YXIgb2JzZXJ2ZXJJZCA9IGdldFJvb3RJZChyb290KSArIChyb290TWFyZ2luID8gdGhyZXNob2xkLnRvU3RyaW5nKCkgKyBcIl9cIiArIHJvb3RNYXJnaW4gOiB0aHJlc2hvbGQudG9TdHJpbmcoKSk7XG4gIHZhciBvYnNlcnZlckluc3RhbmNlID0gT0JTRVJWRVJfTUFQLmdldChvYnNlcnZlcklkKTtcblxuICBpZiAoIW9ic2VydmVySW5zdGFuY2UpIHtcbiAgICBvYnNlcnZlckluc3RhbmNlID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKG9uQ2hhbmdlLCBvcHRpb25zKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblxuICAgIGlmIChvYnNlcnZlcklkKSBPQlNFUlZFUl9NQVAuc2V0KG9ic2VydmVySWQsIG9ic2VydmVySW5zdGFuY2UpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0ge1xuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIGluVmlldzogZmFsc2UsXG4gICAgb2JzZXJ2ZXJJZDogb2JzZXJ2ZXJJZCxcbiAgICBvYnNlcnZlcjogb2JzZXJ2ZXJJbnN0YW5jZSxcbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSB0aGUgdGhyZXNob2xkcyB2YWx1ZS4gSXQncyB1bmRlZmluZWQgb24gYSBicm93c2VyIGxpa2UgQ2hyb21lIDUxLlxuICAgIHRocmVzaG9sZHM6IG9ic2VydmVySW5zdGFuY2UudGhyZXNob2xkcyB8fCAoQXJyYXkuaXNBcnJheSh0aHJlc2hvbGQpID8gdGhyZXNob2xkIDogW3RocmVzaG9sZF0pXG4gIH07XG4gIElOU1RBTkNFX01BUC5zZXQoZWxlbWVudCwgaW5zdGFuY2UpO1xuICBvYnNlcnZlckluc3RhbmNlLm9ic2VydmUoZWxlbWVudCk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbi8qKlxuICogU3RvcCBvYnNlcnZpbmcgYW4gZWxlbWVudC4gSWYgYW4gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSBvciBvdGhlcndpc2UgZGVzdHJveWVkLFxuICogbWFrZSBzdXJlIHRvIGNhbGwgdGhpcyBtZXRob2QuXG4gKiBAcGFyYW0gZWxlbWVudCB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB1bm9ic2VydmUoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHJldHVybjtcbiAgdmFyIGluc3RhbmNlID0gSU5TVEFOQ0VfTUFQLmdldChlbGVtZW50KTtcblxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICB2YXIgb2JzZXJ2ZXJJZCA9IGluc3RhbmNlLm9ic2VydmVySWQsXG4gICAgICAgIG9ic2VydmVyID0gaW5zdGFuY2Uub2JzZXJ2ZXI7XG4gICAgdmFyIHJvb3QgPSBvYnNlcnZlci5yb290O1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTsgLy8gQ2hlY2sgaWYgd2UgYXJlIHN0aWxsIG9ic2VydmluZyBhbnkgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSB0aHJlc2hvbGQuXG5cbiAgICB2YXIgaXRlbXNMZWZ0ID0gZmFsc2U7IC8vIENoZWNrIGlmIHdlIHN0aWxsIGhhdmUgb2JzZXJ2ZXJzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgc2FtZSByb290LlxuXG4gICAgdmFyIHJvb3RPYnNlcnZlZCA9IGZhbHNlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXG4gICAgaWYgKG9ic2VydmVySWQpIHtcbiAgICAgIElOU1RBTkNFX01BUC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gZWxlbWVudCkge1xuICAgICAgICAgIGlmIChpdGVtLm9ic2VydmVySWQgPT09IG9ic2VydmVySWQpIHtcbiAgICAgICAgICAgIGl0ZW1zTGVmdCA9IHRydWU7XG4gICAgICAgICAgICByb290T2JzZXJ2ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdGVtLm9ic2VydmVyLnJvb3QgPT09IHJvb3QpIHtcbiAgICAgICAgICAgIHJvb3RPYnNlcnZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJvb3RPYnNlcnZlZCAmJiByb290KSBST09UX0lEU1tcImRlbGV0ZVwiXShyb290KTtcblxuICAgIGlmIChvYnNlcnZlciAmJiAhaXRlbXNMZWZ0KSB7XG4gICAgICAvLyBObyBtb3JlIGVsZW1lbnRzIHRvIG9ic2VydmUgZm9yIHRocmVzaG9sZCwgZGlzY29ubmVjdCBvYnNlcnZlclxuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH0gLy8gUmVtb3ZlIHJlZmVyZW5jZSB0byBlbGVtZW50XG5cblxuICAgIElOU1RBTkNFX01BUFtcImRlbGV0ZVwiXShlbGVtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNoYW5nZShjaGFuZ2VzKSB7XG4gIGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gaW50ZXJzZWN0aW9uLmlzSW50ZXJzZWN0aW5nLFxuICAgICAgICBpbnRlcnNlY3Rpb25SYXRpbyA9IGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25SYXRpbyxcbiAgICAgICAgdGFyZ2V0ID0gaW50ZXJzZWN0aW9uLnRhcmdldDtcbiAgICB2YXIgaW5zdGFuY2UgPSBJTlNUQU5DRV9NQVAuZ2V0KHRhcmdldCk7IC8vIEZpcmVmb3ggY2FuIHJlcG9ydCBhIG5lZ2F0aXZlIGludGVyc2VjdGlvblJhdGlvIHdoZW4gc2Nyb2xsaW5nLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgIGlmIChpbnN0YW5jZSAmJiBpbnRlcnNlY3Rpb25SYXRpbyA+PSAwKSB7XG4gICAgICAvLyBJZiB0aHJlc2hvbGQgaXMgYW4gYXJyYXksIGNoZWNrIGlmIGFueSBvZiB0aGVtIGludGVyc2VjdHMuIFRoaXMganVzdCB0cmlnZ2VycyB0aGUgb25DaGFuZ2UgZXZlbnQgbXVsdGlwbGUgdGltZXMuXG4gICAgICB2YXIgaW5WaWV3ID0gaW5zdGFuY2UudGhyZXNob2xkcy5zb21lKGZ1bmN0aW9uICh0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmluVmlldyA/IGludGVyc2VjdGlvblJhdGlvID4gdGhyZXNob2xkIDogaW50ZXJzZWN0aW9uUmF0aW8gPj0gdGhyZXNob2xkO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0ludGVyc2VjdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIGlzSW50ZXJzZWN0aW5nIGlzIGRlZmluZWQsIGVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFjdHVhbGx5IGludGVyc2VjdGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHJlcG9ydHMgYSB0aHJlc2hvbGQgb2YgMFxuICAgICAgICBpblZpZXcgPSBpblZpZXcgJiYgaXNJbnRlcnNlY3Rpbmc7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLmluVmlldyA9IGluVmlldztcbiAgICAgIGluc3RhbmNlLmNhbGxiYWNrKGluVmlldywgaW50ZXJzZWN0aW9uKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluQ2hpbGRyZW4ocHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9wcy5jaGlsZHJlbiAhPT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogTW9uaXRvcnMgc2Nyb2xsLCBhbmQgdHJpZ2dlcnMgdGhlIGNoaWxkcmVuIGZ1bmN0aW9uIHdpdGggdXBkYXRlZCBwcm9wc1xuICpcbiA8SW5WaWV3PlxuIHsoe2luVmlldywgcmVmfSkgPT4gKFxuICAgPGgxIHJlZj17cmVmfT57YCR7aW5WaWV3fWB9PC9oMT5cbiApfVxuIDwvSW5WaWV3PlxuICovXG5cblxudmFyIEluVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShJblZpZXcsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEluVmlldygpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGF0ZVwiLCB7XG4gICAgICBpblZpZXc6IGZhbHNlLFxuICAgICAgZW50cnk6IHVuZGVmaW5lZFxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm5vZGVcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlTm9kZVwiLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKF90aGlzLm5vZGUpIHtcbiAgICAgICAgdW5vYnNlcnZlKF90aGlzLm5vZGUpO1xuXG4gICAgICAgIGlmICghbm9kZSAmJiAhX3RoaXMucHJvcHMudHJpZ2dlck9uY2UpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpblZpZXc6IGZhbHNlLFxuICAgICAgICAgICAgZW50cnk6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLm5vZGUgPSBub2RlID8gbm9kZSA6IG51bGw7XG5cbiAgICAgIF90aGlzLm9ic2VydmVOb2RlKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGFuZGxlQ2hhbmdlXCIsIGZ1bmN0aW9uIChpblZpZXcsIGVudHJ5KSB7XG4gICAgICAvLyBPbmx5IHRyaWdnZXIgYSBzdGF0ZSB1cGRhdGUgaWYgaW5WaWV3IGhhcyBjaGFuZ2VkLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhbiB1bm5lY2Vzc2FyeSBleHRyYSBzdGF0ZSB1cGRhdGUgZHVyaW5nIG1vdW50LCB3aGVuIHRoZSBlbGVtZW50IHN0YXRzIG91dHNpZGUgdGhlIHZpZXdwb3J0XG4gICAgICBpZiAoaW5WaWV3ICE9PSBfdGhpcy5zdGF0ZS5pblZpZXcgfHwgaW5WaWV3KSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpblZpZXc6IGluVmlldyxcbiAgICAgICAgICBlbnRyeTogZW50cnlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBhY3RpdmVseSBsaXN0ZW5pbmcgZm9yIG9uQ2hhbmdlLCBhbHdheXMgdHJpZ2dlciBpdFxuICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShpblZpZXcsIGVudHJ5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJblZpZXcucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICF0aGlzLm5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwicmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyOiBObyBET00gbm9kZSBmb3VuZC4gTWFrZSBzdXJlIHlvdSBmb3J3YXJkIFxcXCJyZWZcXFwiIHRvIHRoZSByb290IERPTSBlbGVtZW50IHlvdSB3YW50IHRvIG9ic2VydmUuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgLy8gSWYgYSBJbnRlcnNlY3Rpb25PYnNlcnZlciBvcHRpb24gY2hhbmdlZCwgcmVpbml0IHRoZSBvYnNlcnZlclxuICAgIGlmIChwcmV2UHJvcHMucm9vdE1hcmdpbiAhPT0gdGhpcy5wcm9wcy5yb290TWFyZ2luIHx8IHByZXZQcm9wcy5yb290ICE9PSB0aGlzLnByb3BzLnJvb3QgfHwgcHJldlByb3BzLnRocmVzaG9sZCAhPT0gdGhpcy5wcm9wcy50aHJlc2hvbGQpIHtcbiAgICAgIHVub2JzZXJ2ZSh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy5vYnNlcnZlTm9kZSgpO1xuICAgIH1cblxuICAgIGlmIChwcmV2U3RhdGUuaW5WaWV3ICE9PSB0aGlzLnN0YXRlLmluVmlldykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaW5WaWV3ICYmIHRoaXMucHJvcHMudHJpZ2dlck9uY2UpIHtcbiAgICAgICAgdW5vYnNlcnZlKHRoaXMubm9kZSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIHVub2JzZXJ2ZSh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9ic2VydmVOb2RlID0gZnVuY3Rpb24gb2JzZXJ2ZU5vZGUoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGUpIHJldHVybjtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICB0aHJlc2hvbGQgPSBfdGhpcyRwcm9wcy50aHJlc2hvbGQsXG4gICAgICAgIHJvb3QgPSBfdGhpcyRwcm9wcy5yb290LFxuICAgICAgICByb290TWFyZ2luID0gX3RoaXMkcHJvcHMucm9vdE1hcmdpbjtcbiAgICBvYnNlcnZlKHRoaXMubm9kZSwgdGhpcy5oYW5kbGVDaGFuZ2UsIHtcbiAgICAgIHRocmVzaG9sZDogdGhyZXNob2xkLFxuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIHJvb3RNYXJnaW46IHJvb3RNYXJnaW5cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGluVmlldyA9IF90aGlzJHN0YXRlLmluVmlldyxcbiAgICAgICAgZW50cnkgPSBfdGhpcyRzdGF0ZS5lbnRyeTtcblxuICAgIGlmICghaXNQbGFpbkNoaWxkcmVuKHRoaXMucHJvcHMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih7XG4gICAgICAgIGluVmlldzogaW5WaWV3LFxuICAgICAgICBlbnRyeTogZW50cnksXG4gICAgICAgIHJlZjogdGhpcy5oYW5kbGVOb2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIGFzID0gX3RoaXMkcHJvcHMyLmFzLFxuICAgICAgICB0YWcgPSBfdGhpcyRwcm9wczIudGFnLFxuICAgICAgICB0cmlnZ2VyT25jZSA9IF90aGlzJHByb3BzMi50cmlnZ2VyT25jZSxcbiAgICAgICAgdGhyZXNob2xkID0gX3RoaXMkcHJvcHMyLnRocmVzaG9sZCxcbiAgICAgICAgcm9vdCA9IF90aGlzJHByb3BzMi5yb290LFxuICAgICAgICByb290TWFyZ2luID0gX3RoaXMkcHJvcHMyLnJvb3RNYXJnaW4sXG4gICAgICAgIG9uQ2hhbmdlID0gX3RoaXMkcHJvcHMyLm9uQ2hhbmdlLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiwgW1wiY2hpbGRyZW5cIiwgXCJhc1wiLCBcInRhZ1wiLCBcInRyaWdnZXJPbmNlXCIsIFwidGhyZXNob2xkXCIsIFwicm9vdFwiLCBcInJvb3RNYXJnaW5cIiwgXCJvbkNoYW5nZVwiXSk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChhcyB8fCB0YWcgfHwgJ2RpdicsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogdGhpcy5oYW5kbGVOb2RlXG4gICAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIEluVmlldztcbn0oQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KEluVmlldywgXCJkaXNwbGF5TmFtZVwiLCAnSW5WaWV3Jyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShJblZpZXcsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgdGhyZXNob2xkOiAwLFxuICB0cmlnZ2VyT25jZTogZmFsc2Vcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGluVmlldzogZmFsc2UsXG4gIGVudHJ5OiB1bmRlZmluZWRcbn07XG5mdW5jdGlvbiB1c2VJblZpZXcob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlZiA9IHVzZVJlZigpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSB1c2VTdGF0ZShpbml0aWFsU3RhdGUpLFxuICAgICAgc3RhdGUgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgc2V0UmVmID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgIHVub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG9ic2VydmUobm9kZSwgZnVuY3Rpb24gKGluVmlldywgaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpblZpZXc6IGluVmlldyxcbiAgICAgICAgICBlbnRyeTogaW50ZXJzZWN0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpblZpZXcgJiYgb3B0aW9ucy50cmlnZ2VyT25jZSkge1xuICAgICAgICAgIC8vIElmIGl0IHNob3VsZCBvbmx5IHRyaWdnZXIgb25jZSwgdW5vYnNlcnZlIHRoZSBlbGVtZW50IGFmdGVyIGl0J3MgaW5WaWV3XG4gICAgICAgICAgdW5vYnNlcnZlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBub2RlLCBzbyB3ZSBjYW4gdW5vYnNlcnZlIGl0IGxhdGVyXG5cblxuICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgfSwgW29wdGlvbnMudGhyZXNob2xkLCBvcHRpb25zLnJvb3QsIG9wdGlvbnMucm9vdE1hcmdpbiwgb3B0aW9ucy50cmlnZ2VyT25jZV0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghcmVmLmN1cnJlbnQgJiYgc3RhdGUgIT09IGluaXRpYWxTdGF0ZSAmJiAhb3B0aW9ucy50cmlnZ2VyT25jZSkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHJlZiwgdGhlbiByZXNldCB0aGUgc3RhdGUgKHVubGVzcyB0aGUgaG9vayBpcyBzZXQgdG8gb25seSBgdHJpZ2dlck9uY2VgKVxuICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGNvcnJlY3RseSByZWZsZWN0IHRoZSBjdXJyZW50IHN0YXRlIC0gSWYgeW91IGFyZW4ndCBvYnNlcnZpbmcgYW55dGhpbmcsIHRoZW4gbm90aGluZyBpcyBpblZpZXdcbiAgICAgIHNldFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtzZXRSZWYsIHN0YXRlLmluVmlldywgc3RhdGUuZW50cnldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJblZpZXc7XG5leHBvcnQgeyBJblZpZXcsIHVzZUluVmlldyB9O1xuIiwidmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG52YXIgcHJlZml4ID0gJ0ludmFyaWFudCBmYWlsZWQnO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgXCI6IFwiICsgKG1lc3NhZ2UgfHwgJycpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW52YXJpYW50O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==